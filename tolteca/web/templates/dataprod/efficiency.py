import scipy.interpolate as interpolate
from matplotlib import pyplot as plt
import plotly.graph_objs as go
from glob import glob
import numpy as np
import netCDF4
import os
plt.ion()

# This class supports the viewing of Efficiency data through either
# matplotlib or dasha hooks.  The data is stored in netcdf files
# generated by Efficiency.py and stored in a directory referenced by
# the input filepath below.


class Efficiency():
    def __init__(self, filepath):
        # check that the path exists and that Efficiency files are present
        if not os.path.isdir(filepath):
            raise Exception("No such directory {}".format(filepath))
        flist = glob(os.path.join(filepath, 'Efficiency_N*.nc'))
        print('Found {0:} Efficiency files in {1:}'.format(
            len(flist), filepath))
        if(len(flist) == 0):
            raise Exception("No Efficiency files found in {}".format(filepath))
        flist.sort()
        r10 = [i for i in flist if 'N10' in i]
        r11 = [i for i in flist if 'N11' in i]
        r12 = [i for i in flist if 'N12' in i]
        if(len(r10) > 0):
            flist.sort(key=r10[0].__eq__)
        if(len(r11) > 0):
            flist.sort(key=r11[0].__eq__)
        if(len(r12) > 0):
            flist.sort(key=r12[0].__eq__)

        # generate dictionaries of metadata
        self.nets = {'exists': [0]*13, }
        self.goodNets = []
        for f in flist:
            meta = {}
            try:
                nc = netCDF4.Dataset(f)
                meta['network'] = int(nc.network)
                nc.close()
            except:
                return None
            meta['file'] = f
            if(meta['network'] <= 6):
                meta['array'] = 'a1100'
            elif(meta['network'] >= 11):
                meta['array'] = 'a2000'
            else:
                meta['array'] = 'a1400'
            self.nets['N{}'.format(meta['network'])] = meta
            self.nets['exists'][meta['network']] = 1
            self.goodNets.append('N{}'.format(meta['network']))

    def getArrayData(self):
        # collect fres and efficiency for all available resonances
        for n in self.goodNets:
            nc = netCDF4.Dataset(self.nets[n]['file'])
            self.nets[n]['fres'] = nc.variables['resonantFrequency'][:].data.tolist()
            # gotta remove outliers
            s = nc.variables['efficiency'][:].data
            w = np.where((s < 0) | (s > 0.5))
            s[w] = 0
            self.nets[n]['signal'] = s.tolist()
            self.nets[n]['signal_name'] = 'Efficiency'
            self.nets[n]['signal_units'] = 'unitless'
            nc.close()
        return

    def getNetworkAverageValues(self):
        for n in self.goodNets:
            nc = netCDF4.Dataset(self.nets[n]['file'])
            fr = nc.variables['resonantFrequency'][:].data
            self.nets[n]['fr'] = fr.tolist()
            self.nets[n]['efficiency'] = nc.variables['efficiency'][:].data.tolist()
            nc.close()
        return

    def getArrayAverageValues(self):
        def avgArray(array):
            ap = []
            for n in self.goodNets:
                if(self.nets[n]['array'] == array):
                    ap.append(n)
            eff = []
            for a in ap:
                eff.append(self.nets[n]['efficiency'])
            eff = np.array(eff).mean()
            r = {'meanEff': eff}
            return r
        self.a1100 = avgArray('a1100')
        self.a1400 = avgArray('a1400')
        self.a2000 = avgArray('a2000')
        return

    def matPlotNetworkAvg(self, network, fhigh=500):
        if((network < 0) | (network > 12)):
            print("No such network: {}".format(network))
            return
        # check that the network has Efficiency data
        if(self.nets['exists'][network] == 0):
            print("No Efficiency data for Network {}".format(network))
            return
        plt.ion()
        plt.clf()
        plt.xlim(0, fhigh)
        plt.title('Efficiency for Network {}'.format(network))
        plt.xlabel('Resonant Frequency [MHz]')
        plt.ylabel('Efficiency')
        n = 'N{}'.format(network)
        plt.plot(self.nets[n]['fr'], self.nets[n]['efficiency'])
        return

    def getPlotlyNetworkAvg(self, data, ns):
        fig = go.Figure()
        xaxis, yaxis = getXYAxisLayouts()
        xaxis['title'] = 'Resonnat Frequency [MHz]'
        yaxis['title'] = 'Integral Normalized Spectrum'
        for n in ns:
            if(n in data['goodNets']):
                fr = data['nets'][n]['fr']
                sc = np.array(data['nets'][n]['efficiency'])
                # remove outliers
                w = np.where((sc < 0.5) & (sc > 0.))[0]
                sc = sc[w].tolist()
                fig.add_trace(
                    go.Scattergl(x=fr, y=sc, mode='markers',
                                 name="Network {}".format(n)))
        fig.update_layout(
            uirevision=True,
            showlegend=True,
            width=1200,
            height=400,
            xaxis=xaxis,
            yaxis=yaxis,
            autosize=True,
            margin=dict(
                autoexpand=True,
                l=10,
                r=10,
                t=30,
            ),
            plot_bgcolor='white'
        )
        return fig


# common figure axis definitions
def getXYAxisLayouts():
    xaxis = dict(
        titlefont=dict(size=20),
        showline=True,
        showgrid=False,
        showticklabels=True,
        linecolor='black',
        linewidth=4,
        ticks='outside',
        tickfont=dict(
            family='Arial',
            size=18,
            color='rgb(82, 82, 82)',
        ),
    )

    yaxis = dict(
        titlefont=dict(size=20),
        showline=True,
        showgrid=False,
        showticklabels=True,
        linecolor='black',
        linewidth=4,
        ticks='outside',
        tickfont=dict(
            family='Arial',
            size=18,
            color='rgb(82, 82, 82)',
        ),
    )
    return xaxis, yaxis


def getEmptyFig(width, height):
    xaxis, yaxis = getXYAxisLayouts()
    fig = go.Figure()
    fig.update_layout(
        uirevision=True,
        showlegend=False,
        width=width,
        height=height,
        xaxis=xaxis,
        yaxis=yaxis,
        autosize=True,
        margin=dict(
            autoexpand=True,
            l=10,
            r=10,
            t=30,
        ),
        plot_bgcolor='white'
    )
    return fig
