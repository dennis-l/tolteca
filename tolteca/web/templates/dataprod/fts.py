import scipy.interpolate as interpolate
from matplotlib import pyplot as plt
import plotly.graph_objs as go
from glob import glob
import numpy as np
import netCDF4
import os
plt.ion()

# This class supports the viewing of FTS data through either
# matplotlib or dasha hooks.  The data is stored in netcdf files
# generated by FTSReduce.py and stored in a directory referenced by
# the input filepath below.


class FTS():
    def __init__(self, filepath):
        # check that the path exists and that FTS files are present
        if not os.path.isdir(filepath):
            raise Exception("No such directory {}".format(filepath))
        flist = glob(os.path.join(filepath, 'FTS*.nc'))
        print('Found {0:} FTS files in {1:}'.format(len(flist), filepath))
        if(len(flist) == 0):
            raise Exception("No FTS files found in {}".format(filepath))
        gn = [n.split('_')[2] for n in flist]
        flist = [flist[n] for n in np.argsort(gn)]
        r10 = [i for i in flist if 'N10' in i]
        r11 = [i for i in flist if 'N11' in i]
        r12 = [i for i in flist if 'N12' in i]
        if(len(r10) > 0):
            flist.sort(key=r10[0].__eq__)
        if(len(r11) > 0):
            flist.sort(key=r11[0].__eq__)
        if(len(r12) > 0):
            flist.sort(key=r12[0].__eq__)

        # generate dictionaries of metadata
        self.nets = {'exists': [0]*13, }
        self.goodNets = []
        for f in flist:
            meta = {}
            try:
                nc = netCDF4.Dataset(f)
                meta['network'] = int(nc.network)
                nc.close()
            except:
                return None
            meta['file'] = f
            if(meta['network'] <= 6):
                meta['array'] = 'a1100'
            elif(meta['network'] >= 11):
                meta['array'] = 'a2000'
            else:
                meta['array'] = 'a1400'
            self.nets['N{}'.format(meta['network'])] = meta
            self.nets['exists'][meta['network']] = 1
            self.goodNets.append('N{}'.format(meta['network']))

    def getArrayData(self):
        # collect fres and s2n for all available resonances
        for n in self.goodNets:
            nc = netCDF4.Dataset(self.nets[n]['file'])
            self.nets[n]['fres'] = nc.variables['resonantFrequency'][:].data.tolist()
            self.nets[n]['signal'] = nc.variables['s2n'][:].data.tolist()
            self.nets[n]['signal_name'] = 'FTS S/N'
            self.nets[n]['signal_units'] = 'unitless'
            nc.close()
        return

    def getNetworkAverageValues(self):
        for n in self.goodNets:
            nc = netCDF4.Dataset(self.nets[n]['file'])
            f = nc.variables['fc'][:].data
            w = np.where(f >= 70)[0]
            self.nets[n]['fc'] = f[w].tolist()
            self.nets[n]['sc'] = nc.variables['sc'][:].data[w].tolist()
            nc.close()
        return

    def getArrayAverageValues(self):
        def avgArray(array):
            ap = []
            for n in self.goodNets:
                if(self.nets[n]['array'] == array):
                    ap.append(n)
            if len(ap) == 0:
                return None
            f = self.nets[ap[0]]['fc']
            s = np.zeros(len(f))
            for a in ap:
                fs = interpolate.interp1d(self.nets[a]['fc'],
                                          self.nets[a]['sc'])
                s += fs(f)/len(ap)
            r = {'fc': f, 'sc': s.tolist()}
            return r
        self.a1100 = avgArray('a1100')
        self.a1400 = avgArray('a1400')
        self.a2000 = avgArray('a2000')
        return

    def matPlotNetworkAvg(self, network, fhigh=500):
        if((network < 0) | (network > 12)):
            print("No such network: {}".format(network))
            return
        # check that the network has FTS data
        if(self.nets['exists'][network] == 0):
            print("No FTS data for Network {}".format(network))
            return
        plt.ion()
        plt.clf()
        plt.xlim(0, fhigh)
        plt.title('Average FTS Spectra for Network {}'.format(network))
        plt.xlabel('Frequency [GHz]')
        plt.ylabel('Integral Normalized Spectrum')
        n = 'N{}'.format(network)
        plt.plot(self.nets[n]['fc'], self.nets[n]['sc'])
        return

    def matPlotArrayAvg(self, array, fhigh=500):
        if(array == 'a1100'):
            a = self.a1100
        elif(array == 'a1400'):
            a = self.a1400
        else:
            a = self.a2000
        plt.ion()
        plt.clf()
        plt.xlim(0, fhigh)
        plt.title('Average FTS Spectra for Array {}'.format(array))
        plt.xlabel('Frequency [GHz]')
        plt.ylabel('Integral Normalized Spectrum')
        plt.plot(a['fc'], a['sc'])
        return

    def getPlotlyArrayAvg(self, array, fhigh=500):
        if(array == 'a1100'):
            a = self.a1100
        elif(array == 'a1400'):
            a = self.a1400
        else:
            a = self.a2000
        fc = np.array(a['fc'])
        w = np.where(fc <= fhigh)[0]
        fc = fc[w]
        sc = np.array(a['sc'])[w]

        fig = go.Figure()
        xaxis, yaxis = getXYAxisLayouts()
        xaxis['title'] = 'Frequency [GHz]'
        yaxis['title'] = 'Integral Normalized Spectrum'
        fig.add_trace(
            go.Scattergl(x=fc, y=sc, mode='lines'))
        return fig

    def getPlotlyNetworkAvg(self, data, ns, fhigh=500):
        fig = go.Figure()
        xaxis, yaxis = getXYAxisLayouts()
        xaxis['title'] = 'Frequency [GHz]'
        yaxis['title'] = 'Integral Normalized Spectrum'
        for n in ns:
            if(n in data['goodNets']):
                fc = data['nets'][n]['fc']
                w = np.where(np.array(fc) < fhigh)[0]
                fc = np.array(fc)[w].tolist()
                sc = np.array(data['nets'][n]['sc'])[w].tolist()
                fig.add_trace(
                    go.Scattergl(x=fc, y=sc, mode='lines',
                                 name="Network {}".format(n)))
        fig.update_layout(
            uirevision=True,
            showlegend=True,
            width=1200,
            height=400,
            xaxis=xaxis,
            yaxis=yaxis,
            autosize=True,
            margin=dict(
                autoexpand=True,
                l=10,
                r=10,
                t=30,
            ),
            plot_bgcolor='white'
        )
        return fig


# common figure axis definitions
def getXYAxisLayouts():
    xaxis = dict(
        titlefont=dict(size=20),
        showline=True,
        showgrid=False,
        showticklabels=True,
        linecolor='black',
        linewidth=4,
        ticks='outside',
        tickfont=dict(
            family='Arial',
            size=18,
            color='rgb(82, 82, 82)',
        ),
    )

    yaxis = dict(
        titlefont=dict(size=20),
        showline=True,
        showgrid=False,
        showticklabels=True,
        linecolor='black',
        linewidth=4,
        ticks='outside',
        tickfont=dict(
            family='Arial',
            size=18,
            color='rgb(82, 82, 82)',
        ),
    )
    return xaxis, yaxis


def getEmptyFig(width, height):
    xaxis, yaxis = getXYAxisLayouts()
    fig = go.Figure()
    fig.update_layout(
        uirevision=True,
        showlegend=False,
        width=width,
        height=height,
        xaxis=xaxis,
        yaxis=yaxis,
        autosize=True,
        margin=dict(
            autoexpand=True,
            l=10,
            r=10,
            t=30,
        ),
        plot_bgcolor='white'
    )
    return fig
